<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ReactiveUI</name>
    </assembly>
    <members>
        <member name="T:ReactiveUI.EqualityTypeConverter">
            <summary>
            The default converter, simply converts between types that are equal or
            can be converted (i.e. Button =&gt; UIControl)
            </summary>
        </member>
        <member name="T:ReactiveUI.StringConverter">
            <summary>
            Calls ToString on types. In WPF, ComponentTypeConverter should win
            instead of this, since It's Betterâ„¢.
            </summary>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``3(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String)">
            <summary>
            Bind a command from the ViewModel to the control on the View of the
            same name.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="propertyName">The ViewModel command to Bind.</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="propertyName">The ViewModel command to Bind.</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.IObservable{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="propertyName">The ViewModel command to Bind.</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``1,``4}},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.DesignModeDetector.#ctor">
            <summary>
            Private constructor to prevent instantiation.
            </summary>
        </member>
        <member name="M:ReactiveUI.DesignModeDetector.IsInDesignMode">
            <summary>
            Determines is this application is currently running in a designer.
            </summary>
            <returns>true if in designer; otherwise false</returns>
        </member>
        <member name="T:ReactiveUI.StockUserErrorIcon">
            <summary>
            Describes a stock error icon situation - it is up to the UI to decide
            how to interpret these icons.
            </summary>
        </member>
        <member name="T:ReactiveUI.IRecoveryCommand">
            <summary>
            A command that represents a recovery from an error. These commands
            will typically be displayed as buttons in the error dialog.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRecoveryCommand.CommandName">
            <summary>
            The command name, typically displayed as the button text.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRecoveryCommand.RecoveryResult">
            <summary>
            When the command is invoked and a result is determined, the
            command should set the recovery result to indicate the action the
            throwing code should take.
            </summary>
        </member>
        <member name="T:ReactiveUI.RecoveryOptionResult">
            <summary>
            RecoveryOptionResult describes to the code throwing the UserError what
            to do once the error is resolved.
            </summary>
        </member>
        <member name="F:ReactiveUI.RecoveryOptionResult.CancelOperation">
            <summary>
            The operation should be cancelled, but it is no longer an error.
            </summary>
        </member>
        <member name="F:ReactiveUI.RecoveryOptionResult.RetryOperation">
            <summary>
            The operation should be retried with the same parameters.
            </summary>
        </member>
        <member name="F:ReactiveUI.RecoveryOptionResult.FailOperation">
            <summary>
            Recovery failed or not possible, you should rethrow as an
            Exception.
            </summary>
        </member>
        <member name="T:ReactiveUI.UserError">
            <summary>
            User Errors are similar to Exceptions, except that they are intended
            to be displayed to the user. As such, your error messages should be
            phrased in a friendly way. When a UserError is thrown, code higher up
            in the stack has a chance to resolve the UserError via a user
            interaction.
            Code can also add "Recovery Options" which resolve user errors: for
            example an "Out of Disk Space" error might have an "Open Explorer"
            recovery option.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.ContextInfo">
            <summary>
            A Dictionary that allows UserErrors to contain arbitrary
            application data.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.RecoveryOptions">
            <summary>
            The list of available Recovery Options that will be presented to
            the user to resolve the issue - these usually correspond to
            buttons in the dialog.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.ErrorMessage">
            <summary>
            The "Newspaper Headline" of the message being conveyed to the
            user. This should be one line, short, and informative.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.ErrorCauseOrResolution">
            <summary>
            Additional optional information to describe what is happening, or
            the resolution to an information-only error (i.e. a dialog to tell
            the user that something has happened)
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.UserErrorIcon">
            <summary>
            This object is either a custom icon (usually an ImageSource), or
            it can also be a StockUserErrorIcon. It can also be an
            application-defined type that the handlers know to interpret.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.InnerException">
            <summary>
            Optionally, The actual Exception that warranted throwing the
            UserError.
            </summary>
        </member>
        <member name="M:ReactiveUI.UserError.Throw(System.String,System.Exception)">
            <summary>
            Initiate a user interaction (i.e. "Throw the error to the user to
            deal with") - this method is the simplest way to prompt the user
            that an error has occurred.
            </summary>
            <param name="errorMessage">The message to show to the user. The
            upper level handlers registered with RegisterHandler are
            ultimately responsible for displaying this information.</param>
            <param name="innerException">The Exception that was thrown, if
            relevant - this will *not* ever be shown to the user.</param>
            <returns>An Observable representing the action the code should
            attempt to take, if any.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.Throw(ReactiveUI.UserError)">
            <summary>
            Initiate a user interaction (i.e. "Throw the error to the user to
            deal with").
            </summary>
            <param name="error">The UserError to show to the user. The
            upper level handlers registered with RegisterHandler are
            ultimately responsible for displaying this information. </param>
            <returns>
            </returns>
        </member>
        <member name="M:ReactiveUI.UserError.RegisterHandler(System.Func{ReactiveUI.UserError,System.IObservable{ReactiveUI.RecoveryOptionResult}})">
            <summary>
            Register code to handle a UserError. Registered handlers are
            called in reverse order to their registration (i.e. the newest
            handler is called first), and they each have a chance to handle a
            UserError.
            If a Handler cannot resolve a UserError, it should return null
            instead of an Observable result.
            </summary>
            <param name="errorHandler">A method that can handle a UserError,
            usually by presenting it to the user. If the handler cannot handle
            the error, it should return null.</param>
            <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.RegisterHandler``1(System.Func{``0,System.IObservable{ReactiveUI.RecoveryOptionResult}})">
            <summary>
            Register code to handle a specific type of UserError. Registered
            handlers are called in reverse order to their registration (i.e.
            the newest handler is called first), and they each have a chance
            to handle a UserError.
            If a Handler cannot resolve a UserError, it should return null
            instead of an Observable result.
            </summary>
            <param name="errorHandler">A method that can handle a UserError,
            usually by presenting it to the user. If the handler cannot handle
            the error, it should return null.</param>
            <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.RegisterHandler(System.Func{ReactiveUI.UserError,System.Threading.Tasks.Task{ReactiveUI.RecoveryOptionResult}})">
            <summary>
            Register code to handle a UserError. Registered handlers are
            called in reverse order to their registration (i.e. the newest
            handler is called first), and they each have a chance to handle a
            UserError.
            If a Handler cannot resolve a UserError, it should return null
            instead of an Observable result.
            </summary>
            <param name="errorHandler">A method that can handle a UserError,
            usually by presenting it to the user. If the handler cannot handle
            the error, it should return null.</param>
            <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.RegisterHandler``1(System.Func{``0,System.Threading.Tasks.Task{ReactiveUI.RecoveryOptionResult}})">
            <summary>
            Register code to handle a specific type of UserError. Registered
            handlers are called in reverse order to their registration (i.e.
            the newest handler is called first), and they each have a chance
            to handle a UserError.
            If a Handler cannot resolve a UserError, it should return null
            instead of an Observable result.
            </summary>
            <param name="errorHandler">A method that can handle a UserError,
            usually by presenting it to the user. If the handler cannot handle
            the error, it should return null.</param>
            <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.AddRecoveryOption(ReactiveUI.IRecoveryCommand,System.Func{ReactiveUI.UserError,System.Boolean})">
            <summary>
            This method is a convenience wrapper around RegisterHandler that
            adds the specified RecoveryCommand to any UserErrors that match
            its filter.
            </summary>
            <param name="command">The RecoveryCommand to add.</param>
            <param name="filter">An optional filter to determine which
            UserErrors to add the command to.</param>
            <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.OverrideHandlersForTesting(System.Func{ReactiveUI.UserError,System.IObservable{ReactiveUI.RecoveryOptionResult}})">
            <summary>
            This method replaces *all* UserError handlers with the specified
            handler. Use it for testing code that may throw UserErrors.
            </summary>
            <param name="errorHandler">The replacement UserError handler.</param>
            <returns>An IDisposable which will unregister the test handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.OverrideHandlersForTesting(System.Func{ReactiveUI.UserError,ReactiveUI.RecoveryOptionResult})">
            <summary>
            This method replaces *all* UserError handlers with the specified
            handler. Use it for testing code that may throw UserErrors.
            </summary>
            <param name="errorHandler">The replacement UserError handler.</param>
            <returns>An IDisposable which will unregister the test handler.</returns>
        </member>
        <member name="T:ReactiveUI.UnhandledUserErrorException">
            <summary>
            This Exception will be thrown when a UserError is not handled by any
            of the registered handlers.
            </summary>
        </member>
        <member name="T:ReactiveUI.RecoveryCommand">
            <summary>
            RecoveryCommand is a straightforward implementation of a recovery
            command - this class represents a command presented to the user
            (usually in the form of a button) that will help resolve or mitigate a
            UserError.
            </summary>
        </member>
        <member name="M:ReactiveUI.RecoveryCommand.#ctor(System.String,System.Func{System.Object,ReactiveUI.RecoveryOptionResult})">
            <summary>
            Constructs a RecoveryCommand.
            </summary>
            <param name="commandName">The user-visible name of this Command.</param>
            <param name="handler">A convenience handler - equivalent to
            Subscribing to the command and setting the RecoveryResult.</param>
        </member>
        <member name="P:ReactiveUI.RecoveryCommand.Ok">
            <summary>
            A default command whose caption is "Ok"
            </summary>
            <value>RetryOperation</value>
        </member>
        <member name="P:ReactiveUI.RecoveryCommand.Cancel">
            <summary>
            A default command whose caption is "Cancel"
            </summary>
            <value>FailOperation</value>
        </member>
        <member name="P:ReactiveUI.RecoveryCommand.Yes">
            <summary>
            A default command whose caption is "Yes"
            </summary>
            <value>RetryOperation</value>
        </member>
        <member name="P:ReactiveUI.RecoveryCommand.No">
            <summary>
            A default command whose caption is "No"
            </summary>
            <value>FailOperation</value>
        </member>
        <member name="T:ReactiveUI.IDependencyResolver">
            <summary>
            Represents a dependency resolver, a service to look up global class
            instances or types.
            </summary>
        </member>
        <member name="M:ReactiveUI.IDependencyResolver.GetService(System.Type,System.String)">
            <summary>
            Gets an instance of the given <paramref name="serviceType" />. Must return <c>null</c>
            if the service is not available (must not throw).
            </summary>
            <param name="serviceType">The object type.</param>
            <returns>The requested object, if found; <c>null</c> otherwise.</returns>
        </member>
        <member name="M:ReactiveUI.IDependencyResolver.GetServices(System.Type,System.String)">
            <summary>
            Gets all instances of the given <paramref name="serviceType" />. Must return an empty
            collection if the service is not available (must not return <c>null</c> or throw).
            </summary>
            <param name="serviceType">The object type.</param>
            <returns>A sequence of instances of the requested <paramref name="serviceType" />. The sequence
            should be empty (not <c>null</c>) if no objects of the given type are available.</returns>
        </member>
        <member name="T:ReactiveUI.IMutableDependencyResolver">
            <summary>
            Represents a dependency resolver where types can be registered after
            setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.DependencyResolverMixins.GetService``1(ReactiveUI.IDependencyResolver,System.String)">
            <summary>
            Gets an instance of the given <paramref name="serviceType" />. Must return <c>null</c>
            if the service is not available (must not throw).
            </summary>
            <param name="serviceType">The object type.</param>
            <returns>The requested object, if found; <c>null</c> otherwise.</returns>
        </member>
        <member name="M:ReactiveUI.DependencyResolverMixins.GetServices``1(ReactiveUI.IDependencyResolver,System.String)">
            <summary>
            Gets all instances of the given <paramref name="serviceType" />. Must return an empty
            collection if the service is not available (must not return <c>null</c> or throw).
            </summary>
            <param name="serviceType">The object type.</param>
            <returns>A sequence of instances of the requested <paramref name="serviceType" />. The sequence
            should be empty (not <c>null</c>) if no objects of the given type are available.</returns>
        </member>
        <member name="M:ReactiveUI.DependencyResolverMixins.InitializeResolver(ReactiveUI.IMutableDependencyResolver)">
            <summary>
            This method allows you to initialize resolvers with the default
            ReactiveUI types. All resolvers used as the default
            RxApp.DependencyResolver
            </summary>
            <param name="resolver">The resolver to initialize.</param>
        </member>
        <member name="M:ReactiveUI.DependencyResolverMixins.WithResolver(ReactiveUI.IDependencyResolver)">
            <summary>
            Override the default Dependency Resolver until the object returned
            is disposed.
            </summary>
            <param name="resolver">The test resolver to use.</param>
        </member>
        <member name="T:ReactiveUI.FuncDependencyResolver">
            <summary>
            A simple dependency resolver which takes Funcs for all its actions.
            GetService is always implemented via GetServices().LastOrDefault()
            </summary>
        </member>
        <member name="T:ReactiveUI.INPCObservableForProperty">
            <summary>
            Generates Observables based on observing INotifyPropertyChanged objects
            </summary>
        </member>
        <member name="T:ReactiveUI.IRNPCObservableForProperty">
            <summary>
            Generates Observables based on observing Reactive objects
            </summary>
        </member>
        <member name="T:ReactiveUI.IObservedChange`2">
            <summary>
            IObservedChange is a generic interface that replaces the non-generic
            PropertyChangedEventArgs. Note that it is used for both Changing (i.e.
            'before change') and Changed Observables. In the future, this interface
            will be Covariant which will allow simpler casting between specific and
            generic changes.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Sender">
            <summary>
            The object that has raised the change.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.PropertyName">
            <summary>
            The name of the property that has changed on Sender.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Value">
            <summary>
            The value of the property that has changed. IMPORTANT NOTE: This
            property is often not set for performance reasons, unless you have
            explicitly requested an Observable for a property via a method such
            as ObservableForProperty. To retrieve the value for the property,
            use the Value() extension method.
            </summary>
        </member>
        <member name="T:ReactiveUI.ObservedChange`2">
            <summary>
            A data-only version of IObservedChange
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyPropertyChanged">
            <summary>
            IReactiveNotifyPropertyChanged represents an extended version of
            INotifyPropertyChanged that also exposes Observables.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyPropertyChanged.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed. Note that this should not fire duplicate change notifications if a
            property is set to the same value multiple times.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyPropertyChanged.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            Note that this should not fire duplicate change notifications if a
            property is set to the same value multiple times.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveNotifyPropertyChanged.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyPropertyChanged`1">
            <summary>
            IReactiveNotifyPropertyChanged of TSender is a helper interface that adds
            typed versions of Changing and Changed.
            </summary>
        </member>
        <member name="T:ReactiveUI.IHandleObservableErrors">
            <summary>
            This interface is implemented by RxUI objects which are given
            IObservables as input - when the input IObservables OnError, instead of
            disabling the RxUI object, we catch the IObservable and pipe it into
            this property.
            Normally this IObservable is implemented with a ScheduledSubject whose
            default Observer is RxApp.DefaultExceptionHandler - this means, that if
            you aren't listening to ThrownExceptions and one appears, the exception
            will appear on the UI thread and crash the application.
            </summary>
        </member>
        <member name="P:ReactiveUI.IHandleObservableErrors.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI
            internal state.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveCommand">
            <summary>
            IReactiveCommand represents an ICommand which also notifies when it is
            executed (i.e. when Execute is called) via IObservable. Conceptually,
            this represents an Event, so as a result this IObservable should never
            OnComplete or OnError.
            In previous versions of ReactiveUI, this interface was split into two
            separate interfaces, one to handle async methods and one for "standard"
            commands, but these have now been merged - every ReactiveCommand is now
            a ReactiveAsyncCommand.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveCommand.RegisterAsync``1(System.Func{System.Object,System.IObservable{``0}})">
            <summary>
            Registers an asynchronous method to be called whenever the command
            is Executed. This method returns an IObservable representing the
            asynchronous operation, and is allowed to OnError / should OnComplete.
            </summary>
            <returns>A filtered version of the Observable which is marshaled
            to the UI thread. This Observable should only report successes and
            instead send OnError messages to the ThrownExceptions property.
            </returns>
            <param name="asyncBlock">The asynchronous method to call.</param>
        </member>
        <member name="P:ReactiveUI.IReactiveCommand.CanExecuteObservable">
            <summary>
            Gets a value indicating whether this instance can execute observable.
            </summary>
            <value>
                <c>true</c> if this instance can execute observable; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:ReactiveUI.IReactiveCommand.IsExecuting">
            <summary>
            Gets a value indicating whether this instance is executing. This
            Observable is guaranteed to always return a value immediately (i.e.
            it is backed by a BehaviorSubject), meaning it is safe to determine
            the current state of the command via IsExecuting.First()
            </summary>
            <value>
                <c>true</c> if this instance is executing; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:ReactiveUI.IReactiveCommand.AllowsConcurrentExecution">
            <summary>
            Gets a value indicating whether this
            <see cref="T:ReactiveUI.IReactiveCommand" /> allows concurrent
            execution. If false, the CanExecute of the command will be disabled
            while async operations are currently in-flight.
            </summary>
            <value>
                <c>true</c> if allows concurrent execution; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:ReactiveUI.IReactiveCollection">
            <summary>
            IReactiveCollection represents a collection that can notify when its
            contents are changed (either items are added/removed, or the object
            itself changes).
            It is important to implement the Changing/Changed from
            IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
            the collection or any of its items have changed, in any way".
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.ItemsAdded">
            <summary>
            Fires when items are added to the collection, once per item added.
            Functions that add multiple items such AddRange should fire this
            multiple times. The object provided is the item that was added.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.BeforeItemsAdded">
            <summary>
            Fires before an item is going to be added to the collection.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.ItemsRemoved">
            <summary>
            Fires once an item has been removed from a collection, providing the
            item that was removed.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.BeforeItemsRemoved">
            <summary>
            Fires before an item will be removed from a collection, providing
            the item that will be removed.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.CountChanged">
            <summary>
            Fires whenever the number of items in a collection has changed,
            providing the new Count.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.CountChanging">
            <summary>
            Fires before a collection is about to change, providing the previous
            Count.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.IsEmptyChanged">
            <summary>
            Fires when a collection becomes or stops being empty.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.ItemChanging">
            <summary>
            Provides Item Changing notifications for any item in collection that
            implements IReactiveNotifyPropertyChanged. This is only enabled when
            ChangeTrackingEnabled is set to True.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.ItemChanged">
            <summary>
            Provides Item Changed notifications for any item in collection that
            implements IReactiveNotifyPropertyChanged. This is only enabled when
            ChangeTrackingEnabled is set to True.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.ChangeTrackingEnabled">
            <summary>
            Enables the ItemChanging and ItemChanged properties; when this is
            enabled, whenever a property on any object implementing
            IReactiveNotifyPropertyChanged changes, the change will be
            rebroadcast through ItemChanging/ItemChanged.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.Changing">
            <summary>
            This Observable is equivalent to the NotifyCollectionChanged event,
            but fires before the collection is changed
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.Changed">
            <summary>
            This Observable is equivalent to the NotifyCollectionChanged event,
            and fires after the collection is changed
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection.ShouldReset">
            <summary>
            This Observable is fired when a ShouldReset fires on the collection. This
            means that you should forget your previous knowledge of the state
            of the collection and reread it.
            This does *not* mean Clear, and if you interpret it as such, you are
            Doing It Wrong.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveCollection`1">
            <summary>
            IReactiveCollection of T is the typed version of IReactiveCollection and
            adds type-specified versions of Observables
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection`1.ItemsAdded">
            <summary>
            Fires when items are added to the collection, once per item added.
            Functions that add multiple items such AddRange should fire this
            multiple times. The object provided is the item that was added.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection`1.BeforeItemsAdded">
            <summary>
            Fires before an item is going to be added to the collection.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection`1.ItemsRemoved">
            <summary>
            Fires once an item has been removed from a collection, providing the
            item that was removed.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection`1.BeforeItemsRemoved">
            <summary>
            Fires before an item will be removed from a collection, providing
            the item that will be removed.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection`1.ItemChanging">
            <summary>
            Provides Item Changing notifications for any item in collection that
            implements IReactiveNotifyPropertyChanged. This is only enabled when
            ChangeTrackingEnabled is set to True.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCollection`1.ItemChanged">
            <summary>
            Provides Item Changed notifications for any item in collection that
            implements IReactiveNotifyPropertyChanged. This is only enabled when
            ChangeTrackingEnabled is set to True.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveList`1">
            <summary>
            An IList that reports change notifications
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutingState.NavigationStack">
            <summary>
            Represents the current navigation stack, the last element in the
            collection being the currently visible ViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutingState.NavigateBack">
            <summary>
            Navigates back to the previous element in the stack.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutingState.Navigate">
            <summary>
            Navigates to the a new element in the stack - the Execute parameter
            must be a ViewModel that implements IRoutableViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutingState.NavigateAndReset">
            <summary>
            Navigates to a new element and resets the navigation stack (i.e. the
            new ViewModel will now be the only element in the stack) - the
            Execute parameter must be a ViewModel that implements
            IRoutableViewModel.
            </summary>
        </member>
        <member name="T:ReactiveUI.IRoutableViewModel">
            <summary>
            Implement this interface for ViewModels that can be navigated to.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutableViewModel.UrlPathSegment">
            <summary>
            A string token representing the current ViewModel, such as 'login' or 'user'
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutableViewModel.HostScreen">
            <summary>
            The IScreen that this ViewModel is currently being shown in. This
            is usually passed into the ViewModel in the Constructor and saved
            as a ReadOnly Property.
            </summary>
        </member>
        <member name="T:ReactiveUI.ViewContractAttribute">
            <summary>
            Allows an additional string to make view resolution more specific than just a type.
            </summary>
        </member>
        <member name="P:ReactiveUI.ViewContractAttribute.Contract">
            <summary>
            A unique string that will be used along with the type to resolve a View
            </summary>
        </member>
        <member name="T:ReactiveUI.IEnableLogger">
            <summary>
            "Implement" this interface in your class to get access to the Log()
            Mixin, which will give you a Logger that includes the class name in the
            log.
            </summary>
        </member>
        <member name="P:ReactiveUI.LogHost.Default">
            <summary>
            Use this logger inside miscellaneous static methods where creating
            a class-specific logger isn't really worth it.
            </summary>
        </member>
        <member name="M:ReactiveUI.LogHost.Log``1(``0)">
            <summary>
            Call this method to write log entries on behalf of the current
            class.
            </summary>
        </member>
        <member name="T:ReactiveUI.MemoizingMRUCache`2">
            <summary>
            This data structure is a representation of a memoizing cache - i.e. a
            class that will evaluate a function, but keep a cache of recently
            evaluated parameters.
            Since this is a memoizing cache, it is important that this function be a
            "pure" function in the mathematical sense - that a key *always* maps to
            a corresponding return value.
            </summary>
            <typeparam name="TParam">The type of the parameter to the calculation function.</typeparam>
            <typeparam name="TVal">The type of the value returned by the calculation
            function.</typeparam>
        </member>
        <member name="M:ReactiveUI.MemoizingMRUCache`2.#ctor(System.Func{`0,System.Object,`1},System.Int32,System.Action{`1})">
            <summary>
            Constructor
            </summary>
            <param name="calculationFunc">The function whose results you want to cache,
            which is provided the key value, and an Tag object that is
            user-defined</param>
            <param name="maxSize">The size of the cache to maintain, after which old
            items will start to be thrown out.</param>
            <param name="onRelease">A function to call when a result gets
            evicted from the cache (i.e. because Invalidate was called or the
            cache is full)</param>
        </member>
        <member name="M:ReactiveUI.MemoizingMRUCache`2.Get(`0,System.Object)">
            <summary>
            Evaluates the function provided, returning the cached value if possible
            </summary>
            <param name="key">The value to pass to the calculation function.</param>
            <param name="context">An additional optional user-specific parameter.</param>
            <returns>
            </returns>
        </member>
        <member name="M:ReactiveUI.MemoizingMRUCache`2.Invalidate(`0)">
            <summary>
            Ensure that the next time this key is queried, the calculation
            function will be called.
            </summary>
        </member>
        <member name="M:ReactiveUI.MemoizingMRUCache`2.InvalidateAll">
            <summary>
            Invalidate all items in the cache
            </summary>
        </member>
        <member name="M:ReactiveUI.MemoizingMRUCache`2.CachedValues">
            <summary>
            Returns all values currently in the cache
            </summary>
            <returns>
            </returns>
        </member>
        <member name="T:ReactiveUI.MessageBus">
            <summary>
            MessageBus represents an object that can act as a "Message Bus", a
            simple way for ViewModels and other objects to communicate with each
            other in a loosely coupled way.
            Specifying which messages go where is done via a combination of the Type
            of the message as well as an additional "Contract" parameter; this is a
            unique string used to distinguish between messages of the same Type, and
            is arbitrarily set by the client.
            </summary>
        </member>
        <member name="P:ReactiveUI.MessageBus.Current">
            <summary>
            Gets or sets the Current MessageBus.
            </summary>
        </member>
        <member name="M:ReactiveUI.MessageBus.RegisterScheduler``1(System.Reactive.Concurrency.IScheduler,System.String)">
            <summary>
            Registers a scheduler for the type, which may be specified at runtime, and the contract.
            </summary>
            <remarks>If a scheduler is already registered for the specified runtime and contract, this will overrwrite the existing registration.</remarks>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="scheduler">The scheduler on which to post the
            notifications for the specified type and contract. RxApp.MainThreadScheduler by default.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.MessageBus.Listen``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.ListenIncludeLatest``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.IsRegistered(System.Type,System.String)">
            <summary>
            Determines if a particular message Type is registered.
            </summary>
            <param name="type">The Type of the message to listen to.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>True if messages have been posted for this message Type.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.RegisterMessageSource``1(System.IObservable{``0},System.String)">
            <summary>
            Registers an Observable representing the stream of messages to send.
            Another part of the code can then call Listen to retrieve this
            Observable.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="source">An Observable that will be subscribed to, and a
            message sent out for each value provided.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.MessageBus.SendMessage``1(``0,System.String)">
            <summary>
            Sends a single message using the specified Type and contract.
            Consider using RegisterMessageSource instead if you will be sending
            messages in response to other changes such as property changes
            or events.
            </summary>
            <typeparam name="T">The type of the message to send.</typeparam>
            <param name="message">The actual message to send</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="T:ReactiveUI.ModernDependencyResolver">
            <summary>
            This class is a dependency resolver written for modern C# 5.0 times.
            It implements all registrations via a Factory method. With the power
            of Closures, you can actually implement most lifetime styles (i.e.
            construct per call, lazy construct, singleton) using this.
            Unless you have a very compelling reason not to, this is the only class
            you need in order to do dependency resolution, don't bother with using
            a full IoC container.
            </summary>
        </member>
        <member name="T:ReactiveUI.NullDefaultPropertyBindingProvider">
            <summary>
            Null default property binding provider.
            </summary>
        </member>
        <member name="T:ReactiveUI.ObservableAsPropertyHelper`1">
            <summary>
            ObservableAsPropertyHelper is a class to help ViewModels implement
            "output properties", that is, a property that is backed by an
            Observable. The property will be read-only, but will still fire change
            notifications. This class can be created directly, but is more often created via the
            ToProperty and ObservableToProperty extension methods.
            This class is also an Observable itself, so that output properties can
            be chained - for example a "Path" property and a chained
            "PathFileNameOnly" property.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.#ctor(System.IObservable{`0},System.Action{`0},`0,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs an ObservableAsPropertyHelper object.
            </summary>
            <param name="observable">The Observable to base the property on.</param>
            <param name="onChanged">The action to take when the property
            changes, typically this will call the ViewModel's
            RaisePropertyChanged method.</param>
            <param name="initialValue">The initial value of the property.</param>
            <param name="scheduler">The scheduler that the notifications will be
            provided on - this should normally be a Dispatcher-based scheduler
            (and is by default)</param>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.Value">
            <summary>
            The last provided value from the Observable.
            </summary>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI
            internal state.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.Default(`0,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs a "default" ObservableAsPropertyHelper object. This is
            useful for when you will initialize the OAPH later, but don't want
            bindings to access a null OAPH at startup.
            </summary>
            <param name="initialValue">The initial (and only) value of the property.</param>
            <param name="scheduler">The scheduler that the notifications will be
            provided on - this should normally be a Dispatcher-based scheduler
            (and is by default)</param>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.
            </summary>
            <param name="source">The ReactiveObject that has the property</param>
            <param name="property">An Expression representing the property (i.e.
            'x =&gt; x.SomeProperty'</param>
            <param name="initialValue">The initial value of the property.</param>
            <param name="scheduler">The scheduler that the notifications will be
            provided on - this should normally be a Dispatcher-based scheduler
            (and is by default)</param>
            <returns>An initialized ObservableAsPropertyHelper; use this as the
            backing field for your property.</returns>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},ReactiveUI.ObservableAsPropertyHelper{``1}@,``1,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.
            </summary>
            <param name="source">The ReactiveObject that has the property</param>
            <param name="property">An Expression representing the property (i.e.
            'x =&gt; x.SomeProperty'</param>
            <param name="initialValue">The initial value of the property.</param>
            <param name="scheduler">The scheduler that the notifications will be
            provided on - this should normally be a Dispatcher-based scheduler
            (and is by default)</param>
            <returns>An initialized ObservableAsPropertyHelper; use this as the
            backing field for your property.</returns>
        </member>
        <member name="T:ReactiveUI.ObservableAsyncMRUCache`2">
            <summary>
            ObservableAsyncMRUCache implements memoization for asynchronous or
            expensive to compute methods. This memoization is an MRU-based cache
            with a fixed limit for the number of items in the cache.
            This class guarantees that only one calculation for any given key is
            in-flight at a time, subsequent requests will wait for the first one and
            return its results (for example, an empty web image cache that receives
            two concurrent requests for "Foo.jpg" will only issue one WebRequest -
            this does not mean that a request for "Bar.jpg" will wait on "Foo.jpg").
            Concurrency is also limited by the maxConcurrent parameter - when too
            many in-flight operations are in progress, further operations will be
            queued until a slot is available.
            </summary>
            <typeparam name="TParam">The key type.</typeparam>
            <typeparam name="TVal">The type of the value to return from the cache.</typeparam>
        </member>
        <member name="M:ReactiveUI.ObservableAsyncMRUCache`2.#ctor(System.Func{`0,System.IObservable{`1}},System.Int32,System.Int32,System.Action{`1},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs an ObservableAsyncMRUCache object.
            </summary>
            <param name="calculationFunc">The function that performs the
            expensive or asyncronous calculation and returns an async result -
            for CPU-based operations, Observable.Return may be used to return
            the result.
            Note that this function *must* return an equivalently-same result given a
            specific input - because the function is being memoized, if the
            calculationFunc depends on other varables other than the input
            value, the results will be unpredictable.
            </param>
            <param name="maxSize">The number of items to cache. When this limit
            is reached, not recently used items will be discarded.</param>
            <param name="maxConcurrent">The maximum number of concurrent
            asynchronous operations regardless of key - this is important for
            web-based caches to limit the number of concurrent requests to a
            server. The default is 5.</param>
            <param name="onRelease">This optional method is called when an item
            is evicted from the cache - this can be used to clean up / manage an
            on-disk cache; the calculationFunc can download a file and save it
            to a temporary folder, and the onRelease action will delete the
            file.</param>
            <param name="sched">The scheduler to run asynchronous operations on
            - defaults to TaskpoolScheduler</param>
        </member>
        <member name="M:ReactiveUI.ObservableAsyncMRUCache`2.AsyncGet(`0)">
            <summary>
            Issues an request to fetch the value for the specified key as an
            async operation. The Observable returned will fire one time when the
            async operation finishes. If the operation is cached, an Observable
            that immediately fires upon subscribing will be returned.
            </summary>
            <param name="key">The key to provide to the calculation function.</param>
            <returns>Returns an Observable representing the future result.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableAsyncMRUCache`2.Get(`0)">
            <summary>
            The synchronous version of AsyncGet - it will issue a request for
            the value of a specific key and wait until the value can be
            provided.
            </summary>
            <param name="key">The key to provide to the calculation function.</param>
            <returns>The resulting value.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableCacheMixin.CachedSelectMany``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}},System.Int32,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Works like SelectMany, but memoizes selector calls. In addition, it
            guarantees that no more than 'maxConcurrent' selectors are running
            concurrently and queues the rest. This is very important when using
            web services to avoid potentially spamming the server with hundreds
            of requests.
            </summary>
            <param name="selector">A selector similar to one you would pass as a
            parameter passed to SelectMany. Note that similarly to
            ObservableAsyncMRUCache.AsyncGet, a selector must return semantically
            identical results given the same key - i.e. it must be a 'function' in
            the mathematical sense.</param>
            <param name="maxCached">The number of items to cache. When this limit
            is reached, not recently used items will be discarded.</param>
            <param name="maxConcurrent">The maximum number of concurrent
            asynchronous operations regardless of key - this is important for
            web-based caches to limit the number of concurrent requests to a
            server. The default is 5.</param>
            <param name="scheduler">
            </param>
            <returns>An Observable representing the flattened results of the
            selector.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableCacheMixin.CachedSelectMany``2(System.IObservable{``0},ReactiveUI.ObservableAsyncMRUCache{``0,``1})">
            <summary>
            Works like SelectMany, but memoizes selector calls. In addition, it
            guarantees that no more than 'maxConcurrent' selectors are running
            concurrently and queues the rest. This is very important when using
            web services to avoid potentially spamming the server with hundreds
            of requests.
            This overload is useful when making the same web service call in
            several places in the code, to ensure that all of the code paths are
            using the same cache.
            </summary>
            <param name="existingCache">An already-configured ObservableAsyncMRUCache.</param>
            <returns>An Observable representing the flattened results of the
            cache selector.</returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.GetValue``2(ReactiveUI.IObservedChange{``0,``1})">
            <summary>
            Returns the current value of a property given a notification that
            it has changed.
            </summary>
            <returns>The current value of the property</returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.TryGetValue``2(ReactiveUI.IObservedChange{``0,``1},``1@)">
            <summary>
            Attempts to return the current value of a property given a
            notification that it has changed. If any property in the
            property expression is null, false is returned.
            </summary>
            <param name="changeValue">The value of the property
            expression.</param>
            <returns>True if the entire expression was able to be followed,
            false otherwise</returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.SetValueToProperty``3(ReactiveUI.IObservedChange{``0,``1},``2,System.Linq.Expressions.Expression{System.Func{``2,``1}})">
            <summary>
            Given a fully filled-out IObservedChange object, SetValueToProperty
            will apply it to the specified object (i.e. it will ensure that
            target.property == This.GetValue() and "replay" the observed change
            onto another object)
            </summary>
            <param name="target">The target object to apply the change to.</param>
            <param name="property">The target property to apply the change to.</param>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.Value``2(System.IObservable{ReactiveUI.IObservedChange{``0,``1}})">
            <summary>
            Given a stream of notification changes, this method will convert
            the property changes to the current value of the property.
            </summary>
            <returns>An Observable representing the stream of current values of
            the given change notification stream.</returns>
        </member>
        <member name="T:ReactiveUI.IComparerBuilder`1">
            <summary>
            Convienience interface for providing a starting point for chaining comparers.
            </summary>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="T:ReactiveUI.OrderedComparer">
            <summary>
            Convienience class providing a starting point for chaining comparers for anonymous types.
            </summary>
            <remarks>
            If the type you're creating a comparer for is known this class is nothing more than an alias for the generic
            OrderedComparer. This class can be used to create comparers for anonymous types
            </remarks>
        </member>
        <member name="M:ReactiveUI.OrderedComparer.For``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a type inferred comparer builder for the element type of the enumerable. Useful for creating
            comparers for anonymous types. Note that the builder is not a comparer in itself, you need to use the
            OrderBy or OrderByDescending methods on the builder to get an actual comparer.
            </summary>
        </member>
        <member name="M:ReactiveUI.OrderedComparer.For``1">
            <summary>
            Creates a comparer builder for the specified type. Note that the builder is not a comparer in itself,
            you need to use the OrderBy or OrderByDescending methods on the builder to get an actual comparer.
            If the type is known at compile time this method is nothing more than an alias for the generic
            OrdedComparer class.
            </summary>
        </member>
        <member name="T:ReactiveUI.OrderedComparer`1">
            <summary>
            Convienience class providing a starting point for chaining comparers.
            </summary>
            <typeparam name="T">
            </typeparam>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Creates a comparer that will sort elements in ascending order based on the values returned by the provided
            selector. The values will be compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a comparer that will sort elements in ascending order based on the values returned by the provided
            selector. The selector values will be compared using the provided comparer or the default comparer for the
            return type of the selector if no comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector.
            The default comparer for that type will be used if this parameter is null.
            </param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            Creates a comparer that will sort elements in descending order based on the values returned by the provided
            selector. The values will be compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a comparer that will sort elements in descending order based on the values returned by the provided
            selector. The selector values will be compared using the provided comparer or the default comparer for the
            return type of the selector if no comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector.
            The default comparer for that type will be used if this parameter is null.
            </param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenBy``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenBy``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenByDescending``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenByDescending``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="T:ReactiveUI.POCOObservableForProperty">
            <summary>
            This class is the final fallback for WhenAny, and will simply immediately
            return the value of the type at the time it was created. It will also
            warn the user that this is probably not what they want to do
            </summary>
        </member>
        <member name="T:ReactiveUI.BindingMixins">
            <summary>
            This class provides extension methods for the ReactiveUI view binding mechanism.
            </summary>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view =&gt; view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``3(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Object)">
            <summary>
            Binds the specified view model property to the given view,
            and tries to automagically guess the control/property to be bound on the
            view by looking at the name of the property bound on the view model.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the specified view model property to the given view property, and
            provide a custom view update signaller to signal when the view property has been updated.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate" />
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view =&gt; view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.IObservable{``3},System.Object)">
            <summary>
            Binds the specified view model property to an automagically guessed control/property on the view, and
            provide a custom view update signaller to signal when the view property has been updated.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate" />
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the given property on the view model to a given property on the view in a one-way (view model to view) fashion.
            </summary>
            <typeparam name="TViewModel">The type of the view model.</typeparam>
            <typeparam name="TView">The type of the view.</typeparam>
            <typeparam name="TVMProp">The type of view model property.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">
            The instance of the view object which is bound. Usually, it is the <code>this</code>
            instance.
            </param>
            <param name="viewModel">
            The view model that is bound.
            It is usually set to the <see cref="P:ReactiveUI.IViewFor.ViewModel" /> property of the <paramref name="view" />.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view =&gt; view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="fallbackValue">
            A function providing a fallback value.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``3(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``2},System.Object)">
            <summary>
            Binds the specified view model property property to the given view in a one-way (view model to view) fashion,
            and tries to automagically guess the control/property to be bound on the
            view by looking at the name of the property bound on the view model.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="fallbackValue">
            A function providing a fallback value.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Binds the specified view model property to the given view, in a one-way (view model to view) fashion,
            with the value of the view model property mapped through a <paramref name="selector" /> function.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector" />.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Binds the specified view model property to the given view, automagically guessing
            the control/property to be bound, in a one-way (view model to view) fashion,
            with the value of the view model property mapped through a <paramref name="selector" /> function.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector" />.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``0},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to "Subscribe(x =&gt;
            target.property = x)", but allows you to use child properties
            without the null checks.
            </summary>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">An expression representing the target
            property to set. This can be a child property (i.e. x.Foo.Bar.Baz).</param>
            <param name="fallbackValue">
            A function that provides a fallback value.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="T:ReactiveUI.IPropertyBinderImplementation">
            <summary>
            This interface represents an object that is capable
            of providing binding implementations.
            </summary>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter" />
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view model that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate" />
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a one-way binding, i.e. a binding that flows from the
            <paramref name="viewModel" /> to the <paramref name="view" /> only. This binding will
            attempt to convert the value of the view model property to the view property if they
            are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
            <exception cref="T:System.ArgumentException">
            There is no registered converter from <typeparamref name="TVMProp" /> to <typeparamref name="TVProp" />.
            </exception>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Creates a one way binding with a selector, i.e. a binding that flows from the
            <paramref name="viewModel" /> to the <paramref name="view" /> only, and where the value of the view model
            property is mapped through the <paramref name="selector" /> before being set to the view.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector" />.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``0},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to "Subscribe(x =&gt;
            target.property = x)", but allows you to use child properties
            without the null checks.
            </summary>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">An expression representing the target
            property to set. This can be a child property (i.e. x.Foo.Bar.Baz).</param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter" />
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view model that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate" />
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <see cref="!:vmProperty" />, and its most natural property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a one-way binding, i.e. a binding that flows from the
            <paramref name="viewModel" /> to the <paramref name="view" /> only. This binding will
            attempt to convert the value of the view model property to the view property if they
            are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <see cref="!:vmProperty" />, and its most natural property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
            <exception cref="T:System.ArgumentException">
            There is no registered converter from <typeparamref name="TVMProp" /> to <typeparamref name="TVProp" />.
            </exception>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Creates a one way binding with a selector, i.e. a binding that flows from the
            <paramref name="viewModel" /> to the <paramref name="view" /> only, and where the value of the view model
            property is mapped through the <paramref name="selector" /> before being set to the view.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector" />.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <see cref="!:vmProperty" />, and its most natural property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable" /> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``0},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to "Subscribe(x =&gt;
            target.property = x)", but allows you to use child properties
            without the null checks.
            </summary>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">An expression representing the target
            property to set. This can be a child property (i.e. x.Foo.Bar.Baz).</param>
            <returns>An object that when disposed, disconnects the binding.</returns>
            <param name="This">This.</param>
            <param name="fallbackValue">Fallback value.</param>
            <param name="conversionHint">Conversion hint.</param>
            <param name="vmToViewConverterOverride">Vm to view converter override.</param>
            <typeparam name="TValue">The 1st type parameter.</typeparam>
            <typeparam name="TTarget">The 2nd type parameter.</typeparam>
            <typeparam name="TTValue">The 3rd type parameter.</typeparam>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`1">
            <summary>
            This class represents a change-notifying Collection which is derived from
            a source collection, via CreateDerivedCollection or via another method.
            It is read-only, and any attempts to change items in the collection will
            fail.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`2">
            <summary>
            This class represents a change-notifying Collection which is derived from
            a source collection, via CreateDerivedCollection or via another method.
            It is read-only, and any attempts to change items in the collection will
            fail.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.canItemStayAtPosition(`1,System.Int32)">
            <summary>
            Gets a value indicating whether or not the item fits (sort-wise) at the provided index. The determination
            is made by checking whether or not it's considered larger than or equal to the preceeding item and if
            it's less than or equal to the succeeding item.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.getIndexFromSourceIndex(System.Int32)">
            <summary>
            Gets the index of the dervived item based on it's originating element index in the source collection.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.indexOfAll(System.Collections.Generic.IEnumerable{`0},`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns one or more positions in the source collection where the given item is found based on the
            provided equality comparer.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.shiftIndicesAtOrOverThreshold(System.Int32,System.Int32)">
            <summary>
            Increases (or decreases) all source indices equal to or higher than the threshold. Represents an
            insert or remove of one or more items in the source list thus causing all subsequent items to shift
            up or down.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`2.ReferenceEqualityComparer`1">
            <summary>
            Internal equality comparer used for looking up the source object of a property change notification in
            the source list.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveCollectionMixins.CreateCollection``1(System.IObservable{``0},System.Nullable{System.TimeSpan},System.Action{System.Exception})">
            <summary>
            Creates a collection based on an an Observable by adding items
            provided until the Observable completes, optionally ensuring a
            delay. Note that if the Observable never completes and withDelay is
            set, this method will leak a Timer. This method also guarantees that
            items are always added via the UI thread.
            </summary>
            <param name="fromObservable">The Observable whose items will be put
            into the new collection.</param>
            <param name="onError">The handler for errors from the Observable. If
            not specified, an error will go to DefaultExceptionHandler.</param>
            <param name="withDelay">If set, items will be populated in the
            collection no faster than the delay provided.</param>
            <returns>A new collection which will be populated with the
            Observable.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCollectionMixins.CreateCollection``2(System.IObservable{``0},System.Func{``0,``1},System.Nullable{System.TimeSpan})">
            <summary>
            Creates a collection based on an an Observable by adding items
            provided until the Observable completes, optionally ensuring a
            delay. Note that if the Observable never completes and withDelay is
            set, this method will leak a Timer. This method also guarantees that
            items are always added via the UI thread.
            </summary>
            <param name="fromObservable">The Observable whose items will be put
            into the new collection.</param>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="withDelay">If set, items will be populated in the
            collection no faster than the delay provided.</param>
            <returns>A new collection which will be populated with the
            Observable.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableCollectionMixin.CreateDerivedCollection``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Func{``1,``1,System.Int32},System.IObservable{``2})">
            <summary>
            Creates a collection whose contents will "follow" another
            collection; this method is useful for creating ViewModel collections
            that are automatically updated when the respective Model collection
            is updated.
            Note that even though this method attaches itself to any
            IEnumerable, it will only detect changes from objects implementing
            INotifyCollectionChanged (like ReactiveList). If your source
            collection doesn't implement this, signalReset is the way to signal
            the derived collection to reorder/refilter itself.
            </summary>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="filter">A filter to determine whether to exclude items
            in the derived collection.</param>
            <param name="orderer">A comparator method to determine the ordering of
            the resulting collection.</param>
            <param name="signalReset">When this Observable is signalled,
            the derived collection will be manually
            reordered/refiltered.</param>
            <returns>A new collection whose items are equivalent to
            Collection.Select().Where().OrderBy() and will mirror changes
            in the initial collection.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableCollectionMixin.CreateDerivedCollection``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Func{``1,``1,System.Int32})">
            <summary>
            Creates a collection whose contents will "follow" another
            collection; this method is useful for creating ViewModel collections
            that are automatically updated when the respective Model collection
            is updated.
            Be aware that this overload will result in a collection that *only*
            updates if the source implements INotifyCollectionChanged. If your
            list changes but isn't a ReactiveList/ObservableCollection,
            you probably want to use the other overload.
            </summary>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="filter">A filter to determine whether to exclude items
            in the derived collection.</param>
            <param name="orderer">A comparator method to determine the ordering of
            the resulting collection.</param>
            <returns>A new collection whose items are equivalent to
            Collection.Select().Where().OrderBy() and will mirror changes
            in the initial collection.</returns>
        </member>
        <member name="T:ReactiveUI.ReactiveCommand">
            <summary>
            ReactiveCommand is the default Command implementation in ReactiveUI, which
            conforms to the spec described in IReactiveCommand.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.RegisterAsync``1(System.Func{System.Object,System.IObservable{``0}})">
            <summary>
            Registers an asynchronous method to be called whenever the command
            is Executed. This method returns an IObservable representing the
            asynchronous operation, and is allowed to OnError / should OnComplete.
            </summary>
            <returns>A filtered version of the Observable which is marshaled
            to the UI thread. This Observable should only report successes and
            instead send OnError messages to the ThrownExceptions property.</returns>
            <param name="asyncBlock">The asynchronous method to call.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand.IsExecuting">
            <summary>
            Gets a value indicating whether this instance is executing. This
            Observable is guaranteed to always return a value immediately (i.e.
            it is backed by a BehaviorSubject), meaning it is safe to determine
            the current state of the command via IsExecuting.First()
            </summary>
            <value>true</value>
            <c>false</c>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI
            internal state.
            </summary>
            <value>The thrown exceptions.</value>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.ToCommand(System.IObservable{System.Boolean},System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            ToCommand is a convenience method for returning a new
            ReactiveCommand based on an existing Observable chain.
            </summary>
            <param name="scheduler">The scheduler to publish events on - default
            is RxApp.MainThreadScheduler.</param>
            <returns>A new ReactiveCommand whose CanExecute Observable is the
            current object.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``1(System.IObservable{``0},System.Windows.Input.ICommand)">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.RegisterAsyncFunction``1(ReactiveUI.IReactiveCommand,System.Func{System.Object,``0},System.Reactive.Concurrency.IScheduler)">
            <summary>
            RegisterAsyncFunction registers an asynchronous method that returns a result
            to be called whenever the Command's Execute method is called.
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
            <param name="scheduler">
            </param>
            <returns>An Observable that will fire on the UI thread once per
            invoecation of Execute, once the async method completes. Subscribe to
            this to retrieve the result of the calculationFunc.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.RegisterAsyncAction(ReactiveUI.IReactiveCommand,System.Action{System.Object},System.Reactive.Concurrency.IScheduler)">
            <summary>
            RegisterAsyncAction registers an asynchronous method that runs
            whenever the Command's Execute method is called and doesn't return a
            result.
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.RegisterAsyncTask``1(ReactiveUI.IReactiveCommand,System.Func{System.Object,System.Threading.Tasks.Task{``0}})">
            <summary>
            RegisterAsyncTask registers an TPL/Async method that runs when a
            Command gets executed and returns the result
            </summary>
            <returns>An Observable that will fire on the UI thread once per
            invoecation of Execute, once the async method completes. Subscribe to
            this to retrieve the result of the calculationFunc.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.RegisterAsyncTask(ReactiveUI.IReactiveCommand,System.Func{System.Object,System.Threading.Tasks.Task})">
            <summary>
            RegisterAsyncTask registers an TPL/Async method that runs when a
            Command gets executed and returns no result.
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
            <returns>An Observable that signals when the Task completes, on
            the UI thread.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,System.Boolean)">
            <summary>
            ObservableForProperty returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject. This method (unlike other Observables that return
            IObservedChange) guarantees that the Value property of
            the IObservedChange is set.
            </summary>
            <param name="property">An Expression representing the property (i.e.
            'x =&gt; x.SomeProperty.SomeOtherProperty'</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``1(``0,System.String[],System.Boolean,System.Boolean)">
            <summary>
            ObservableForPropertyDynamic returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject. This method (unlike other Observables that return
            IObservedChange) guarantees that the Value property of
            the IObservedChange is set.
            </summary>
            <param name="property">An Expression representing the property (i.e.
            'x =&gt; x.SomeProperty.SomeOtherProperty'</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``1,``2},System.Boolean)">
            <summary>
            ObservableForProperty returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject, running the IObservedChange through a Selector
            function.
            </summary>
            <param name="property">An Expression representing the property (i.e.
            'x =&gt; x.SomeProperty'</param>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="T:ReactiveUI.ReactiveObject">
            <summary>
            ReactiveObject is the base object for ViewModel classes, and it
            implements INotifyPropertyChanged. In addition, ReactiveObject provides
            Changing and Changed Observables to monitor object changes.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveObject.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveObject.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveObject.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveObjectExpressionMixin.RaiseAndSetIfChanged``2(``0,``1@,``1,System.String)">
            <summary>
            RaiseAndSetIfChanged fully implements a Setter for a read-write
            property on a ReactiveObject, using CallerMemberName to raise the notification
            and the ref to the backing field to set the property.
            </summary>
            <typeparam name="TObj">The type of the This.</typeparam>
            <typeparam name="TRet">The type of the return value.</typeparam>
            <param name="This">The <see cref="T:ReactiveUI.ReactiveObject" /> raising the notification.</param>
            <param name="backingField">A Reference to the backing field for this
            property.</param>
            <param name="newValue">The new value.</param>
            <param name="propertyName">The name of the property, usually
            automatically provided through the CallerMemberName attribute.</param>
            <returns>The newly set value, normally discarded.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveObjectExpressionMixin.RaisePropertyChanged``1(``0,System.String)">
            <summary>
            Use this method in your ReactiveObject classes when creating custom
            properties where raiseAndSetIfChanged doesn't suffice.
            </summary>
            <param name="This">The instance of ReactiveObject on which the property has changed.</param>
            <param name="propertyName">
            A string representing the name of the property that has been changed.
            Leave <c>null</c> to let the runtime set to caller member name.
            </param>
        </member>
        <member name="M:ReactiveUI.ReactiveObjectExpressionMixin.RaisePropertyChanging``1(``0,System.String)">
            <summary>
            Use this method in your ReactiveObject classes when creating custom
            properties where raiseAndSetIfChanged doesn't suffice.
            </summary>
            <param name="This">The instance of ReactiveObject on which the property has changed.</param>
            <param name="propertyName">
            A string representing the name of the property that has been changed.
            Leave <c>null</c> to let the runtime set to caller member name.
            </param>
        </member>
        <member name="M:ReactiveUI.Testing.ReactiveObjectTestMixin.RaisePropertyChanging(ReactiveUI.ReactiveObject,System.String)">
            <summary>
            RaisePropertyChanging is a helper method intended for test / mock
            scenarios to manually fake a property change.
            </summary>
            <param name="target">The ReactiveObject to invoke
            raisePropertyChanging on.</param>
            <param name="property">The property that will be faking a change.</param>
        </member>
        <member name="M:ReactiveUI.Testing.ReactiveObjectTestMixin.RaisePropertyChanging``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            RaisePropertyChanging is a helper method intended for test / mock
            scenarios to manually fake a property change.
            </summary>
            <param name="target">The ReactiveObject to invoke
            raisePropertyChanging on.</param>
            <param name="property">The property that will be faking a change.</param>
        </member>
        <member name="M:ReactiveUI.Testing.ReactiveObjectTestMixin.RaisePropertyChanged(ReactiveUI.ReactiveObject,System.String)">
            <summary>
            RaisePropertyChanged is a helper method intended for test / mock
            scenarios to manually fake a property change.
            </summary>
            <param name="target">The ReactiveObject to invoke
            raisePropertyChanging on.</param>
            <param name="property">The property that will be faking a change.</param>
        </member>
        <member name="M:ReactiveUI.Testing.ReactiveObjectTestMixin.RaisePropertyChanged``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            RaisePropertyChanged is a helper method intended for test / mock
            scenarios to manually fake a property change.
            </summary>
            <param name="target">The ReactiveObject to invoke
            raisePropertyChanging on.</param>
            <param name="property">The property that will be faking a change.</param>
        </member>
        <member name="T:ReactiveUI.RoutingState">
            <summary>
            RoutingState manages the ViewModel Stack and allows ViewModels to
            navigate to other ViewModels.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigationStack">
            <summary>
            Represents the current navigation stack, the last element in the
            collection being the currently visible ViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigateBack">
            <summary>
            Navigates back to the previous element in the stack.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.Navigate">
            <summary>
            Navigates to the a new element in the stack - the Execute parameter
            must be a ViewModel that implements IRoutableViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigateAndReset">
            <summary>
            Navigates to a new element and resets the navigation stack (i.e. the
            new ViewModel will now be the only element in the stack) - the
            Execute parameter must be a ViewModel that implements
            IRoutableViewModel.
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.FindViewModelInStack``1(ReactiveUI.IRoutingState)">
            <summary>
            Locate the first ViewModel in the stack that matches a certain Type.
            </summary>
            <returns>The matching ViewModel or null if none exists.</returns>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.GetCurrentViewModel(ReactiveUI.IRoutingState)">
            <summary>
            Returns the currently visible ViewModel
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.NavigateCommandFor``1(ReactiveUI.IRoutingState)">
            <summary>
            Creates a ReactiveCommand which will, when invoked, navigate to the
            type specified by the type parameter via looking it up in the
            Dependency Resolver.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.DependencyResolver">
            <summary>
            Gets or sets the dependency resolver. This class is used throughout
            ReactiveUI for many internal operations as well as for general use
            by applications. If this isn't assigned on startup, a default, highly
            capable implementation will be used, and it is advised for most people
            to simply use the default implementation.
            Note that to create your own and assign it to the global dependency
            resolver, you must initialize it via calling InitializeResolver(), or
            else ReactiveUI internal classes will not be registered and Bad Thingsâ„¢
            will happen.
            </summary>
            <value>The dependency resolver.</value>
        </member>
        <member name="P:ReactiveUI.RxApp.MutableResolver">
            <summary>
            Convenience property to return the DependencyResolver cast to a
            MutableDependencyResolver. The default resolver is also a mutable
            resolver, so this will be non-null. Use this to register new types
            on startup if you are using the default resolver
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.MainThreadScheduler">
            <summary>
            MainThreadScheduler is the scheduler used to schedule work items that
            should be run "on the UI thread". In normal mode, this will be
            DispatcherScheduler, and in Unit Test mode this will be Immediate,
            to simplify writing common unit tests.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.TaskpoolScheduler">
            <summary>
            TaskpoolScheduler is the scheduler used to schedule work items to
            run in a background thread. In both modes, this will run on the TPL
            Task Pool (or the normal Threadpool on Silverlight).
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.DefaultExceptionHandler">
            <summary>
            This Observer is signalled whenever an object that has a
            ThrownExceptions property doesn't Subscribe to that Observable. Use
            Observer.Create to set up what will happen - the default is to crash
            the application with an error message.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.InUnitTestRunnerOverride">
            <summary>
            This method allows you to override the return value of
            RxApp.InUnitTestRunner - a null value means that InUnitTestRunner
            will determine this using its normal logic.
            </summary>
        </member>
        <member name="M:ReactiveUI.RxApp.InUnitTestRunner">
            <summary>
            InUnitTestRunner attempts to determine heuristically if the current
            application is running in a unit test framework
            </summary>
            <returns>True if we have determined that a unit test framework is
            currently running.</returns>
        </member>
        <member name="M:ReactiveUI.RxApp.InitializeCustomResolver(System.Action{System.Object,System.Type})">
            <summary>
            This method will initialize your custom service locator with the
            built-in RxUI types. Use this to help initialize containers that
            don't conform easily to IMutableDependencyResolver.
            </summary>
            <param name="registerMethod">Create a method here that will
            register a constant. For example, the NInject version of
            this method might look like:
            (obj, type) =&gt; kernel.Bind(type).ToConstant(obj)
            </param>
        </member>
        <member name="M:ReactiveUI.UnitTestDetector.#ctor">
            <summary>
            Private constructor to prevent instantiation.
            </summary>
        </member>
        <member name="M:ReactiveUI.UnitTestDetector.IsInUnitTestRunner(System.String)">
            <summary>
            Detects if the app is running in a Unit Test runner by trying to load
            the TestScheduler.
            </summary>
            <param name="testType">Type of the test.</param>
            <returns>
            </returns>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{ReactiveUI.IObservedChange{``0,``2},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``9(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``10(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``11(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``12(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``13(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},ReactiveUI.IObservedChange{``0,``12},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``14(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Linq.Expressions.Expression{System.Func{``0,``13}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},ReactiveUI.IObservedChange{``0,``12},ReactiveUI.IObservedChange{``0,``13},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="T:ReactiveUI.WaitForDispatcherScheduler">
            <summary>
            This scheduler attempts to deal with some of the brain-dead defaults
            on certain Microsoft platforms that make it difficult to access the
            Dispatcher during startup. This class wraps a scheduler and if it
            isn't available yet, it simply runs the scheduled item immediately.
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.IReactiveCommand">
            <summary>
            IReactiveCommand is an Rx-enabled version of ICommand that is also an
            Observable. Its Observable fires once for each invocation of
            ICommand.Execute and its value is the CommandParameter that was
            provided.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.IReactiveCommand.CanExecuteObservable">
            <summary>
            Fires whenever the CanExecute of the ICommand changes. Note that
            this should not fire notifications unless the CanExecute changes
            (i.e. it should not fire 'true', 'true').
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.IReactiveAsyncCommand">
            <summary>
            IReactiveAsyncCommand represents commands that run an asynchronous
            operation in the background when invoked.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.IReactiveAsyncCommand.ItemsInflight">
            <summary>
            Fires whenever the number of asynchronous operations in-flight (i.e.
            currently running) changes and provides the new Count.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.IReactiveAsyncCommand.AsyncStartedNotification">
            <summary>
            Should be fired whenever an async operation starts.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.IReactiveAsyncCommand.AsyncCompletedNotification">
            <summary>
            Should be fired whenever an async operation completes.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.IReactiveAsyncCommand.RegisterAsyncObservable``1(System.Func{System.Object,System.IObservable{``0}})">
            <summary>
            RegisterAsyncObservable registers an Rx-based async method whose
            results will be returned on the UI thread.
            </summary>
            <param name="calculationFunc">A calculation method that returns a
            future result, such as a method returned via
            Observable.FromAsyncPattern.</param>
            <returns>An Observable representing the items returned by the
            calculation result. Note that with this method it is possible with a
            calculationFunc to return multiple items per invocation of Execute.</returns>
        </member>
        <member name="P:ReactiveUI.Legacy.IReactiveAsyncCommand.MaximumConcurrent">
            <summary>
            The maximum number of in-flight
            operations at a time - defaults to one.
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.ReactiveAsyncCommand">
            <summary>
            ReactiveAsyncCommand represents commands that run an asynchronous
            operation in the background when invoked. The main benefit of this
            command is that it will keep track of in-flight operations and
            disable/enable CanExecute when there are too many of them (i.e. a
            "Search" button shouldn't have many concurrent requests running if the
            user clicks the button many times quickly)
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommand.#ctor(System.IObservable{System.Boolean},System.Int32,System.Reactive.Concurrency.IScheduler,System.Boolean)">
            <summary>
            Constructs a new ReactiveAsyncCommand.
            </summary>
            <param name="canExecute">An Observable representing when the command
            can execute. If null, the Command can always execute.</param>
            <param name="maximumConcurrent">The maximum number of in-flight
            operations at a time - defaults to one.</param>
            <param name="scheduler">The scheduler to run the asynchronous
            operations on - defaults to the Taskpool scheduler.</param>
            <param name="initialCondition">Initial CanExecute state</param>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommand.Create``1(System.Func{System.Object,``0},System.Action{``0},System.Func{System.Object,System.Boolean},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Create is a helper method to create a basic ReactiveAsyncCommand
            in a non-Rx way, closer to how BackgroundWorker works.
            </summary>
            <param name="calculationFunc">The function that will calculate
            results in the background</param>
            <param name="callbackFunc">The method to be called once the
            calculation function completes. This method is guaranteed to be
            called on the UI thread.</param>
            <param name="maximumConcurrent">The maximum number of in-flight
            operations at a time - defaults to one.</param>
            <param name="scheduler">The scheduler to run the asynchronous
            operations on - defaults to the Taskpool scheduler.</param>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommandMixins.CurrentItemsInFlight(ReactiveUI.Legacy.IReactiveAsyncCommand)">
            <summary>
            This method returns the current number of items in flight.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommandMixins.RegisterAsyncFunction``1(ReactiveUI.Legacy.IReactiveAsyncCommand,System.Func{System.Object,``0},System.Reactive.Concurrency.IScheduler)">
            <summary>
            RegisterAsyncFunction registers an asynchronous method that returns a result
            to be called whenever the Command's Execute method is called.
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
            <param name="scheduler">
            </param>
            <returns>An Observable that will fire on the UI thread once per
            invoecation of Execute, once the async method completes. Subscribe to
            this to retrieve the result of the calculationFunc.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommandMixins.RegisterAsyncAction(ReactiveUI.Legacy.IReactiveAsyncCommand,System.Action{System.Object},System.Reactive.Concurrency.IScheduler)">
            <summary>
            RegisterAsyncAction registers an asynchronous method that runs
            whenever the Command's Execute method is called and doesn't return a
            result.
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommandMixins.RegisterAsyncTask``1(ReactiveUI.Legacy.IReactiveAsyncCommand,System.Func{System.Object,System.Threading.Tasks.Task{``0}})">
            <summary>
            RegisterAsyncTask registers an TPL/Async method that runs when a
            Command gets executed and returns the result
            </summary>
            <returns>An Observable that will fire on the UI thread once per
            invoecation of Execute, once the async method completes. Subscribe to
            this to retrieve the result of the calculationFunc.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommandMixins.RegisterAsyncTask``1(ReactiveUI.Legacy.IReactiveAsyncCommand,System.Func{System.Object,System.Threading.Tasks.Task})">
            <summary>
            RegisterAsyncTask registers an TPL/Async method that runs when a
            Command gets executed and returns no result.
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
            <returns>An Observable that signals when the Task completes, on
            the UI thread.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommandMixins.RegisterMemoizedFunction``1(ReactiveUI.Legacy.IReactiveAsyncCommand,System.Func{System.Object,``0},System.Int32,System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>
            RegisterMemoizedFunction is similar to RegisterAsyncFunction, but
            caches its results so that subsequent Execute calls with the same
            CommandParameter will not need to be run in the background.
            </summary>
            <param name="calculationFunc">The function that performs the
            expensive or asyncronous calculation and returns the result.
            Note that this function *must* return an equivalently-same result given a
            specific input - because the function is being memoized, if the
            calculationFunc depends on other varables other than the input
            value, the results will be unpredictable.</param>
            <param name="maxSize">The number of items to cache. When this limit
            is reached, not recently used items will be discarded.</param>
            <param name="onRelease">This optional method is called when an item
            is evicted from the cache - this can be used to clean up / manage an
            on-disk cache; the calculationFunc can download a file and save it
            to a temporary folder, and the onRelease action will delete the
            file.</param>
            <param name="sched">The scheduler to run asynchronous operations on
            - defaults to TaskpoolScheduler</param>
            <returns>An Observable that will fire on the UI thread once per
            invocation of Execute, once the async method completes. Subscribe to
            this to retrieve the result of the calculationFunc.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveAsyncCommandMixins.RegisterMemoizedObservable``1(ReactiveUI.Legacy.IReactiveAsyncCommand,System.Func{System.Object,System.IObservable{``0}},System.Int32,System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>
            RegisterMemoizedObservable is similar to RegisterAsyncObservable, but
            caches its results so that subsequent Execute calls with the same
            CommandParameter will not need to be run in the background.
            </summary>
            <param name="calculationFunc">The function that performs the
            expensive or asyncronous calculation and returns the result.
            Note that this function *must* return an equivalently-same result given a
            specific input - because the function is being memoized, if the
            calculationFunc depends on other varables other than the input
            value, the results will be unpredictable.
            </param>
            <param name="maxSize">The number of items to cache. When this limit
            is reached, not recently used items will be discarded.</param>
            <param name="onRelease">This optional method is called when an item
            is evicted from the cache - this can be used to clean up / manage an
            on-disk cache; the calculationFunc can download a file and save it
            to a temporary folder, and the onRelease action will delete the
            file.</param>
            <param name="sched">The scheduler to run asynchronous operations on
            - defaults to TaskpoolScheduler</param>
            <returns>An Observable representing the items returned by the
            calculation result. Note that with this method it is possible with a
            calculationFunc to return multiple items per invocation of Execute.</returns>
        </member>
        <member name="T:ReactiveUI.Legacy.ReactiveCommand">
            <summary>
            IReactiveCommand is an Rx-enabled version of ICommand that is also an
            Observable. Its Observable fires once for each invocation of
            ICommand.Execute and its value is the CommandParameter that was
            provided.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.#ctor(System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler,System.Boolean)">
            <summary>
            Creates a new ReactiveCommand object.
            </summary>
            <param name="canExecute">An Observable, often obtained via
            ObservableFromProperty, that defines when the Command can
            execute.</param>
            <param name="scheduler">The scheduler to publish events on - default
            is RxApp.MainThreadScheduler.</param>
            <param name="initialCondition">Initial CanExecute state</param>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.Create(System.Func{System.Object,System.Boolean},System.Action{System.Object},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a new ReactiveCommand object in an imperative, non-Rx way,
            similar to RelayCommand.
            </summary>
            <param name="canExecute">A function that determines when the Command
            can execute.</param>
            <param name="executed">A method that will be invoked when the
            Execute method is invoked.</param>
            <param name="scheduler">The scheduler to publish events on - default
            is RxApp.MainThreadScheduler.</param>
            <returns>A new ReactiveCommand object.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.Create(System.Func{System.Object,System.Threading.Tasks.Task{System.Boolean}},System.Action{System.Object},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a new ReactiveCommand object in an imperative, non-Rx way,
            similar to RelayCommand, only via a TPL Async method
            </summary>
            <param name="canExecute">A function that determines when the Command
            can execute.</param>
            <param name="executed">A method that will be invoked when the
            Execute method is invoked.</param>
            <param name="scheduler">The scheduler to publish events on - default
            is RxApp.MainThreadScheduler.</param>
            <returns>A new ReactiveCommand object.</returns>
        </member>
        <member name="P:ReactiveUI.Legacy.ReactiveCommand.CanExecuteObservable">
            <summary>
            Fires whenever the CanExecute of the ICommand changes.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.ToCommand(System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            ToCommand is a convenience method for returning a new
            ReactiveCommand based on an existing Observable chain.
            </summary>
            <param name="scheduler">The scheduler to publish events on - default
            is RxApp.MainThreadScheduler.</param>
            <returns>A new ReactiveCommand whose CanExecute Observable is the
            current object.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.InvokeCommand``1(System.IObservable{``0},System.Windows.Input.ICommand)">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="T:ReactiveUI.IMessageBus">
            <summary>
            IMessageBus represents an object that can act as a "Message Bus", a
            simple way for ViewModels and other objects to communicate with each
            other in a loosely coupled way.
            Specifying which messages go where is done via a combination of the Type
            of the message as well as an additional "Contract" parameter; this is a
            unique string used to distinguish between messages of the same Type, and
            is arbitrarily set by the client.
            </summary>
        </member>
        <member name="M:ReactiveUI.IMessageBus.RegisterScheduler``1(System.Reactive.Concurrency.IScheduler,System.String)">
            <summary>
            Registers a scheduler for the type, which may be specified at
            runtime, and the contract.
            </summary>
            <remarks>If a scheduler is already registered for the specified
            runtime and contract, this will overrwrite the existing
            registration.</remarks>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="scheduler">The scheduler on which to post the
            notifications for the specified type and contract.
            RxApp.MainThreadScheduler by default.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.IMessageBus.Listen``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>
            </returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.ListenIncludeLatest``1(System.String)">
            <summary>
            ListenIncludeLatest provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage and fire the
            last provided Message immediately if applicable, or null.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.IsRegistered(System.Type,System.String)">
            <summary>
            Determines if a particular message Type is registered.
            </summary>
            <param name="type">The type of the message.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>True if messages have been posted for this message Type.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.RegisterMessageSource``1(System.IObservable{``0},System.String)">
            <summary>
            Registers an Observable representing the stream of messages to send.
            Another part of the code can then call Listen to retrieve this
            Observable.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="source">An Observable that will be subscribed to, and a
            message sent out for each value provided.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.IMessageBus.SendMessage``1(``0,System.String)">
            <summary>
            Sends a single message using the specified Type and contract.
            Consider using RegisterMessageSource instead if you will be sending
            messages in response to other changes such as property changes
            or events.
            </summary>
            <typeparam name="T">The type of the message to send.</typeparam>
            <param name="message">The actual message to send</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="T:ReactiveUI.ICreatesObservableForProperty">
            <summary>
            ICreatesObservableForProperty represents an object that knows how to
            create notifications for a given type of object. Implement this if you
            are porting RxUI to a new UI toolkit, or generally want to enable WhenAny
            for another type of object that can be observed in a unique way.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICreatesObservableForProperty.GetAffinityForObject(System.Type,System.String,System.Boolean)">
            <summary>
            Returns a positive integer when this class supports
            GetNotificationForProperty for this particular Type. If the method
            isn't supported at all, return a non-positive integer. When multiple
            implementations return a positive value, the host will use the one
            which returns the highest value. When in doubt, return '2' or '0'
            </summary>
            <param name="type">The type to query for.</param>
            <returns>A positive integer if GNFP is supported, zero or a negative
            value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesObservableForProperty.GetNotificationForProperty(System.Object,System.String,System.Boolean)">
            <summary>
            Subscribe to notifications on the specified property, given an
            object and a property name.
            </summary>
            <param name="sender">The object to observe.</param>
            <param name="propertyName">The property on the object to observe.
            This property will not be a dotted property, only a simple name.
            </param>
            <param name="beforeChanged">If true, signal just before the
            property value actually changes. If false, signal after the
            property changes.</param>
            <returns>An IObservable which is signalled whenever the specified
            property on the object changes. If this cannot be done for a
            specified value of beforeChanged, return Observable.Never</returns>
        </member>
        <member name="T:ReactiveUI.IBindingTypeConverter">
            <summary>
            This interface is the extensible implementation of IValueConverters for
            Bind and OneWayBind. Implement this to teach Bind and OneWayBind how to
            convert between types.
            </summary>
        </member>
        <member name="M:ReactiveUI.IBindingTypeConverter.GetAffinityForObjects(System.Type,System.Type)">
            <summary>
            Returns a positive integer when this class supports
            TryConvert for this particular Type. If the method isn't supported at
            all, return a non-positive integer. When multiple implementations
            return a positive value, the host will use the one which returns
            the highest value. When in doubt, return '2' or '0'.
            </summary>
            <param name="lhs">The left-hand object to compare (i.e. 'from')</param>
            <param name="rhs">The right-hand object to compare (i.e. 'to')</param>
            <returns>A positive integer if TryConvert is supported,
            zero or a negative value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.IBindingTypeConverter.TryConvert(System.Object,System.Type,System.Object,System.Object@)">
            <summary>
            Convert a given object to the specified type.
            </summary>
            <param name="from">The object to convert.</param>
            <param name="toType">The type to coerce the object to.</param>
            <param name="conversionHint">An implementation-defined value,
            usually to specify things like locale awareness.</param>
            <returns>An object that is of the type 'to'</returns>
        </member>
        <member name="T:ReactiveUI.IDefaultPropertyBindingProvider">
            <summary>
            Implement this to teach Bind and OneWayBind how to guess the most
            "common" property on a given control, so if the caller doesn't specify it,
            it'll pick the right control
            </summary>
        </member>
        <member name="M:ReactiveUI.IDefaultPropertyBindingProvider.GetPropertyForControl(System.Object)">
            <summary>
            Given a certain control, figure out the default property to bind to
            </summary>
            <param name="control">The control to look at.</param>
            <returns>A tuple of PropertyName and Affinity for that property.
            Use the same rules about affinity as others, but return null if
            the property can't be determined.</returns>
        </member>
        <member name="T:ReactiveUI.IPropertyBindingHook">
            <summary>
            Implement this as a way to intercept bindings at the time that they are
            created and execute an additional action (or to cancel the binding)
            </summary>
        </member>
        <member name="M:ReactiveUI.IPropertyBindingHook.ExecuteHook(System.Object,System.Object,System.Func{ReactiveUI.IObservedChange{System.Object,System.Object}[]},System.Func{ReactiveUI.IObservedChange{System.Object,System.Object}[]},ReactiveUI.BindingDirection)">
            <summary>
            Called when any binding is set up.
            </summary>
            <returns>If false, the binding is cancelled</returns>
            <param name="source">The source ViewModel</param>
            <param name="target">The target View (not the actual control)</param>
            <param name="getCurrentViewModelProperties">Get current view model properties.</param>
            <param name="getCurrentViewProperties">Get current view properties.</param>
            <param name="direction">The Binding direction.</param>
        </member>
        <member name="T:ReactiveUI.IViewFor`1">
            <summary>
            Implement this interface on your Views to support Routing and Binding.
            </summary>
        </member>
        <member name="P:ReactiveUI.IViewFor`1.ViewModel">
            <summary>
            The ViewModel corresponding to this specific View. This should be
            a DependencyProperty if you're using XAML.
            </summary>
        </member>
        <member name="T:ReactiveUI.IScreen">
            <summary>
            IScreen represents any object that is hosting its own routing -
            usually this object is your AppViewModel or MainWindow object.
            </summary>
        </member>
        <member name="P:ReactiveUI.IScreen.Router">
            <summary>
            The Router associated with this Screen.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.GetAffinityForObject(System.Type,System.Boolean)">
            <summary>
            Returns a positive integer when this class supports
            BindCommandToObject for this particular Type. If the method
            isn't supported at all, return a non-positive integer. When multiple
            implementations return a positive value, the host will use the one
            which returns the highest value. When in doubt, return '2' or '0'
            </summary>
            <param name="type">The type to query for.</param>
            <param name="hasEventTarget">If true, the host intends to use a custom
            event target.</param>
            <returns>A positive integer if BCTO is supported, zero or a negative
            value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.BindCommandToObject(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object})">
            <summary>
            Bind an ICommand to a UI object, in the "default" way. The meaning
            of this is dependent on the implementation. Implement this if you
            have a new type of UI control that doesn't have
            Command/CommandParameter like WPF or has a non-standard event name
            for "Invoke".
            </summary>
            <param name="command">The command to bind</param>
            <param name="target">The target object, usually a UI control of
            some kind</param>
            <param name="commandParameter">An IObservable source whose latest
            value will be passed as the command parameter to the command. Hosts
            will always pass a valid IObservable, but this may be
            Observable.Empty</param>
            <returns>An IDisposable which will disconnect the binding when
            disposed.</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.BindCommandToObject``1(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object},System.String)">
            <summary>
            Bind an ICommand to a UI object to a specific event. This event may
            be a standard .NET event, or it could be an event derived in another
            manner (i.e. in MonoTouch).
            </summary>
            <param name="command">The command to bind</param>
            <param name="target">The target object, usually a UI control of
            some kind</param>
            <param name="commandParameter">An IObservable source whose latest
            value will be passed as the command parameter to the command. Hosts
            will always pass a valid IObservable, but this may be
            Observable.Empty</param>
            <param name="eventName">The event to bind to.</param>
            <returns>
            </returns>
            <returns>An IDisposable which will disconnect the binding when
            disposed.</returns>
        </member>
        <member name="T:ReactiveUI.IViewLocator">
            <summary>
            Implement this to override how RoutedViewHost and ViewModelViewHost
            map ViewModels to Views.
            </summary>
        </member>
        <member name="M:ReactiveUI.IViewLocator.ResolveView``1(``0,System.String)">
            <summary>
            Determines the view for an associated ViewModel
            </summary>
            <returns>The view, with the ViewModel property assigned to
            viewModel.</returns>
            <param name="viewModel">View model.</param>
            <param name="contract">Contract.</param>
        </member>
        <member name="M:ReactiveUI.RoutableViewModelMixin.WhenNavigatedTo(ReactiveUI.IRoutableViewModel,System.Func{System.IDisposable})">
            <summary>
            This method allows you to set up connections that only operate
            while the ViewModel has focus, and cleans up when the ViewModel
            loses focus.
            </summary>
            <param name="onNavigatedTo">Called when the ViewModel is navigated
            to - return an IDisposable that cleans up all of the things that are
            configured in the method.</param>
            <returns>An IDisposable that lets you disconnect the entire process
            earlier than normal.</returns>
        </member>
        <member name="M:ReactiveUI.DefaultViewLocator.ResolveView``1(``0,System.String)">
            <summary>
            Returns the View associated with a ViewModel, deriving the name of
            the Type via ViewModelToViewFunc, then discovering it via
            ServiceLocator.
            </summary>
            <param name="viewModel">The ViewModel for which to find the
            associated View.</param>
            <returns>The View for the ViewModel.</returns>
        </member>
        <member name="T:ReactiveUI.IReactiveBinding`3">
            <summary>
            This interface represents the result of a Bind/OneWayBind and gives
            information about the binding. When this object is disposed, it will
            destroy the binding it is describing (i.e. most of the time you won't
            actually care about this object, just that it is disposable)
            </summary>
        </member>
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.IReactiveBinding`3.ViewModel-->
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.IReactiveBinding`3.ViewModelPath-->
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.IReactiveBinding`3.ViewModelPathProperties-->
        <member name="P:ReactiveUI.IReactiveBinding`3.View">
            <summary>
            The instance of the view this binding is applied to.
            </summary>
            <value>
            The view.
            </value>
        </member>
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.IReactiveBinding`3.ViewPath-->
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.IReactiveBinding`3.ViewPathProperties-->
        <member name="P:ReactiveUI.IReactiveBinding`3.Changed">
            <summary>
            An observable representing changed values for the binding.
            </summary>
            <value>
            The changed.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.Direction">
            <summary>
            Gets the direction of the binding.
            </summary>
            <value>
            The direction.
            </value>
        </member>
        <member name="M:ReactiveUI.ReactiveBinding`3.#ctor(`0,`1,System.String[],System.String[],System.IObservable{`2},ReactiveUI.BindingDirection,System.IDisposable)">
            <summary>
            Initializes a new instance of the <see cref="!:AppliedBindingInfo&lt;TViewModel&gt;" /> class.
            </summary>
            <param name="view">The view.</param>
            <param name="viewModel">The view model.</param>
            <param name="viewPath">The view path.</param>
            <param name="viewModelPath">The view model path.</param>
            <param name="direction">The direction.</param>
            <param name="bindingDisposable">The binding disposable.</param>
        </member>
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.ReactiveBinding`3.ViewModel-->
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.ReactiveBinding`3.ViewModelPath-->
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.ReactiveBinding`3.ViewModelPathProperties-->
        <member name="P:ReactiveUI.ReactiveBinding`3.View">
            <summary>
            The instance of the view this binding is applied to.
            </summary>
            <value>
            The view.
            </value>
        </member>
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.ReactiveBinding`3.ViewPath-->
        <!--FIXME: Invalid documentation markup was found for member P:ReactiveUI.ReactiveBinding`3.ViewPathProperties-->
        <member name="P:ReactiveUI.ReactiveBinding`3.Changed">
            <summary>
            An observable representing changed values for the binding.
            </summary>
            <value>
            The changed.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.Direction">
            <summary>
            Gets the direction of the binding.
            </summary>
            <value>
            The direction.
            </value>
        </member>
        <member name="M:ReactiveUI.ReactiveBinding`3.Dispose">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
        </member>
    </members>
</doc>
